{% extends "base.html" %}

{% block title %}Cyberbro - Graph Analysis (experimental){% endblock title %}
{% block head %}
{{ super() }}
<script type="text/javascript" src="https://unpkg.com/vis-network@9.1.2/dist/vis-network.min.js"></script>
<link href="https://unpkg.com/vis-network@9.1.2/dist/vis-network.min.css" rel="stylesheet" type="text/css" />
{% endblock head %}

{% block content %}
{{ super() }}
<div class="page-header" style="margin-bottom: var(--spacing-sm);">
    <h1 style="margin-bottom: 0;">Graph Analysis</h1>
    <p style="margin-bottom: 0;">Interactive visualization of observable relationships</p>
</div>

<div class="graph-controls">
    <button class="graph-control-btn" onclick="window.location.href='/results/{{ analysis_id }}'"
        title="Go back to results">
        <span>←</span>
    </button>
    <button class="graph-control-btn" onclick="toggleFullScreen()" title="Toggle fullscreen">
        <span>⛶</span>
    </button>
    <button class="graph-control-btn" id="layoutButton" onclick="switchLayout()" title="Switch layout">
        <span>⚙</span>
    </button>
    <button class="graph-control-btn" id="physicsButton" onclick="togglePhysics()" title="Toggle physics">
        <span>⏸</span>
    </button>
</div>

<style>
    .graph-controls {
        display: flex;
        gap: var(--spacing-xs);
        margin-bottom: var(--spacing-sm);
        flex-wrap: wrap;
    }

    .graph-control-btn {
        background: var(--surface-color);
        border: 1px solid var(--border-color);
        color: var(--text-color);
        padding: var(--spacing-xs) var(--spacing-sm);
        border-radius: var(--radius-md);
        cursor: pointer;
        font-size: 1.25rem;
        line-height: 1;
        transition: all var(--transition-fast);
        box-shadow: var(--shadow-sm);
        min-width: 36px;
        height: 36px;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .graph-control-btn:hover {
        background: var(--primary-color);
        color: white;
        border-color: var(--primary-color);
        transform: translateY(-1px);
        box-shadow: var(--shadow-md);
    }

    .graph-control-btn:active {
        transform: translateY(0);
        box-shadow: var(--shadow-sm);
    }

    body.dark-mode .graph-control-btn {
        background: var(--dark-surface-color);
        border-color: var(--dark-border-color);
        color: var(--dark-text-color);
    }

    body.dark-mode .graph-control-btn:hover {
        background: var(--primary-color);
        color: white;
        border-color: var(--primary-color);
    }
</style>
<script>
    let physicsEnabled = true;

    function togglePhysics() {
        const container = document.getElementById("network");
        if (!container) {
            console.error("Network container not found.");
            return;
        }

        const network = container.networkInstance;
        if (!network) {
            console.error("Network instance is not initialized.");
            return;
        }

        physicsEnabled = !physicsEnabled;
        console.log(`Toggling physics: ${physicsEnabled}`);
        network.setOptions({
            physics: {
                enabled: physicsEnabled,
            },
        });

        const physicsButton = document.getElementById("physicsButton");
        physicsButton.querySelector('span').textContent = physicsEnabled ? "⏸" : "▶";
        physicsButton.title = physicsEnabled ? "Stop physics" : "Start physics";
    }

    let currentLayoutIndex = 0;
    const layouts = [
        { name: "Organic", options: { layout: { randomSeed: undefined } } },
        { name: "Circular", options: { layout: { hierarchical: false } } },
        {
            name: "Orthogonal",
            options: { layout: { hierarchical: { direction: "UD", sortMethod: "directed" } } },
        },
        { name: "Tree", options: { layout: { hierarchical: { direction: "LR", sortMethod: "hubsize" } } } },
        {
            name: "Hierarchical",
            options: { layout: { hierarchical: { direction: "UD", sortMethod: "directed" } } },
        },
    ];

    function switchLayout() {
        const container = document.getElementById("network");
        const network = container.networkInstance;
        if (!network) {
            console.error("Network instance is not initialized.");
            return;
        }

        currentLayoutIndex = (currentLayoutIndex + 1) % layouts.length;
        const selectedLayout = layouts[currentLayoutIndex];
        console.log(`Switching to layout: ${selectedLayout.name}`);

        // Preserve the current physics state
        const currentPhysicsState = physicsEnabled;
        network.setOptions({
            ...(selectedLayout.options || {}),
            physics: { enabled: currentPhysicsState },
        });

        const layoutButton = document.getElementById("layoutButton");
        layoutButton.title = `Switch to ${layouts[(currentLayoutIndex + 1) % layouts.length].name}`;
    }

    function toggleFullScreen() {
        const container = document.getElementById("network");
        if (!document.fullscreenElement) {
            container.requestFullscreen().catch((err) => {
                console.error(`Error attempting to enable full-screen mode: ${err.message}`);
            });
        } else {
            document.exitFullscreen();
        }
    }
</script>
<div id="network"></div>
<!-- </div> -->

<script>
    // Use the builtin Javascript library to get the country name from the country code
    function country_code_to_country_name(country_code) {
        const regionNames = new Intl.DisplayNames(["en"], { type: "region" });
        return regionNames.of(country_code.toUpperCase());
    }

    function generateGraph(data) {
        const nodes = [];
        const edges = [];
        const addedNodes = new Set();

        function addNode(id, label, group = "default", imageUrl = null) {
            if (!addedNodes.has(id)) {
                const newNode = {
                    id,
                    label,
                    group,
                };

                if (imageUrl) {
                    newNode.shape = "image";
                    newNode.image = imageUrl;
                }

                nodes.push(newNode);
                addedNodes.add(id);
            }
        }

        data.forEach((entry) => {
            const obs = entry.observable;
            if (!obs) return;

            addNode(obs, obs, "observable", "https://img.icons8.com/officexs/32/goal.png");

            const providers = ["ipinfo", "ipquery", "webscout", "ipapi"];
            providers.forEach((provider) => {
                if (entry[provider]?.asn) {
                    let asn = String(entry[provider].asn || "");

                    if (provider === "ipquery" && entry[provider]?.isp) {
                        asn = `${asn} ${entry[provider].isp}`.trim();
                    }

                    if (provider === "webscout" && entry[provider]?.as_org) {
                        asn = `${asn} ${entry[provider].as_org}`.trim();
                    }

                    if (provider === "ipapi" && entry[provider]?.asn.org) {
                        asn = `${entry[provider].asn.asn} ${entry[provider].asn.org}`.trim();
                    }

                    if (entry.type === "FQDN" || entry.type === "URL") {
                        if (entry.reverse_dns?.reverse_dns) {
                            if (
                                entry[provider].ip &&
                                entry.reverse_dns.reverse_dns.includes(entry[provider].ip)
                            ) {
                                addNode(asn, asn, "asn", "https://img.icons8.com/officexs/32/organization.png");
                                edges.push({ from: entry[provider].ip, to: asn, label: `ASN (${provider})` });
                            }
                        }
                    } else {
                        addNode(asn, asn, "asn", "https://img.icons8.com/officexs/32/organization.png");
                        edges.push({ from: obs, to: asn, label: `ASN (${provider})` });
                    }
                }

                if (entry[provider]?.country_code || (provider === "ipapi" && entry[provider]?.location?.country_code)) {
                    // Check to see if the provider already has a country name
                    let country, countryCode;

                    if (provider === "ipapi" && entry[provider]?.location) {
                        country = entry[provider].location.country || country_code_to_country_name(entry[provider].location.country_code);
                        countryCode = entry[provider].location.country_code.toLowerCase();
                    } else {
                        country = entry[provider]?.country_name
                            ? entry[provider].country_name
                            : country_code_to_country_name(entry[provider].country_code);
                        countryCode = entry[provider].country_code.toLowerCase();
                    }

                    const flagUrl = `https://cdnjs.cloudflare.com/ajax/libs/flag-icons/6.6.6/flags/1x1/${countryCode}.svg`;

                    addNode(country, country, "country_name", flagUrl);

                    const fromNode =
                        (entry.type === "FQDN" || entry.type === "URL") &&
                            entry.reverse_dns?.reverse_dns?.includes(entry[provider].ip)
                            ? entry[provider].ip
                            : obs;

                    edges.push({ from: fromNode, to: country, label: `Country (${provider})` });
                }

                // Check if the provider has an IP address
                if (entry[provider]?.ip) {
                    // Check for IP address with Spur.us data
                    if (entry.spur?.tunnels && entry.spur.tunnels !== "Not anonymous" && entry.spur.tunnels !== "Unknown - Behind Captcha") {
                        const tunnels = entry.spur.tunnels;
                        if (entry.type === "FQDN" || entry.type === "URL") {
                            if (entry.reverse_dns?.reverse_dns) {
                                if (
                                    entry[provider].ip &&
                                    entry.reverse_dns.reverse_dns.includes(entry[provider].ip)
                                ) {
                                    addNode(
                                        tunnels,
                                        tunnels,
                                        "tunnels",
                                        "https://img.icons8.com/officexs/32/lock.png",
                                    );
                                    edges.push({
                                        from: entry[provider].ip,
                                        to: tunnels,
                                        label: "Tunnel (Spur.us)",
                                    });
                                }
                            }
                        } else {
                            addNode(tunnels, tunnels, "tunnels", "https://img.icons8.com/officexs/32/lock.png");
                            edges.push({ from: obs, to: tunnels, label: "Tunnel (Spur.us)" });
                        }
                    }
                    // check for IP address with IPAPI data (add vpn provider name if applicable)
                    if (entry.ipapi?.is_vpn && entry.ipapi?.vpn?.service) {
                        const vpnService = entry.ipapi.vpn.service;
                        if (entry.type === "FQDN" || entry.type === "URL") {
                            if (entry.reverse_dns?.reverse_dns) {
                                if (
                                    entry[provider].ip &&
                                    entry.reverse_dns.reverse_dns.includes(entry[provider].ip)
                                ) {
                                    addNode(
                                        vpnService,
                                        vpnService,
                                        "vpn_service",
                                        "https://img.icons8.com/officexs/32/lock.png",
                                    );
                                    edges.push({
                                        from: entry[provider].ip,
                                        to: vpnService,
                                        label: "VPN Service (IPAPI)",
                                    });
                                }
                            }
                        } else {
                            addNode(
                                vpnService,
                                vpnService,
                                "vpn_service",
                                "https://img.icons8.com/officexs/32/lock.png",
                            );
                            edges.push({ from: obs, to: vpnService, label: "VPN Service (IPAPI)" });
                        }
                    }


                    // Check for Abusix data
                    if (entry.abusix?.abuse) {
                        const abuseAddress = entry.abusix.abuse;
                        if (entry.type === "FQDN" || entry.type === "URL") {
                            if (entry.reverse_dns?.reverse_dns) {
                                if (
                                    entry[provider].ip &&
                                    entry.reverse_dns.reverse_dns.includes(entry[provider].ip)
                                ) {
                                    addNode(
                                        abuseAddress,
                                        abuseAddress,
                                        "abuse",
                                        "https://img.icons8.com/officexs/32/email.png",
                                    );
                                    edges.push({
                                        from: entry[provider].ip,
                                        to: abuseAddress,
                                        label: "Abuse (Abusix)",
                                    });
                                }
                            }
                        } else {
                            addNode(
                                abuseAddress,
                                abuseAddress,
                                "abuse",
                                "https://img.icons8.com/officexs/32/email.png",
                            );
                            edges.push({ from: obs, to: abuseAddress, label: "Abuse (Abusix)" });
                        }
                    }

                    // Check for Shodan data
                    if (entry.shodan?.ports) {
                        entry.shodan.ports.forEach((port) => {
                            const portNode = `Port ${port}`;
                            if (entry.type === "FQDN" || entry.type === "URL") {
                                if (entry.reverse_dns?.reverse_dns) {
                                    if (
                                        entry[provider].ip &&
                                        entry.reverse_dns.reverse_dns.includes(entry[provider].ip)
                                    ) {
                                        addNode(portNode, portNode, "port");
                                        edges.push({
                                            from: entry[provider].ip,
                                            to: portNode,
                                            label: "Port",
                                        });
                                    }
                                }
                            } else {
                                addNode(portNode, portNode, "port");
                                edges.push({ from: obs, to: portNode, label: "Port" });
                            }
                        });
                    }

                    if (entry.abuseipdb) {
                        const abuseipdbData = entry.abuseipdb;

                        // Skip adding a node if both reports and risk_score are 0
                        if (abuseipdbData.reports === 0 && abuseipdbData.risk_score === 0) {
                            return;
                        }

                        const abuseipdbNode = "AbuseIPDB flagged";
                        let edgeLabel = "";

                        if (abuseipdbData.reports) {
                            edgeLabel += `Reports: ${abuseipdbData.reports}`;
                        }
                        if (abuseipdbData.risk_score) {
                            edgeLabel += (edgeLabel ? ", " : "") + `Risk: ${abuseipdbData.risk_score} %`;
                        }

                        if (entry.type === "FQDN" || entry.type === "URL") {
                            if (entry.reverse_dns?.reverse_dns) {
                                if (
                                    entry[provider]?.ip &&
                                    entry.reverse_dns.reverse_dns.includes(entry[provider]?.ip)
                                ) {
                                    addNode(
                                        abuseipdbNode,
                                        abuseipdbNode,
                                        "abuseipdb_flagged",
                                        "https://www.abuseipdb.com/img/abuseipdb-logo.svg",
                                    );
                                    edges.push({
                                        from: entry[provider]?.ip,
                                        to: abuseipdbNode,
                                        label: edgeLabel,
                                    });
                                }
                            }
                        } else {
                            addNode(
                                abuseipdbNode,
                                abuseipdbNode,
                                "abuseipdb_flagged",
                                "https://www.abuseipdb.com/img/abuseipdb-logo.svg",
                            );
                            edges.push({ from: obs, to: abuseipdbNode, label: edgeLabel });
                        }
                    }
                }

                // end of provider loop
            });

            if (entry.criminalip?.abuse_record_count > 0) {
                const criminalipNode = "Criminal IP flagged";
                addNode(
                    criminalipNode,
                    criminalipNode,
                    "criminalip_flagged",
                    "https://img.icons8.com/?size=32&id=hm3q4mXLU6tz&format=png&color=000000",
                );
                edges.push({
                    from: obs,
                    to: criminalipNode,
                    label: `CriminalIP (${entry.criminalip.abuse_record_count})`,
                });
            }

            if (entry.criminalip?.whois?.data[0]?.as_no) {
                const asn = `${entry.criminalip.whois.data[0].as_no} ${entry.criminalip.whois.data[0].as_name}`;
                addNode(asn, asn, "asn", "https://img.icons8.com/officexs/32/organization.png");
                edges.push({ from: obs, to: asn, label: `ASN (Criminal IP)` });
            }

            if (entry.criminalip?.whois?.data[0]?.org_country_code) {
                const countryCode = entry.criminalip.whois.data[0].org_country_code.toLowerCase();
                const country = country_code_to_country_name(entry.criminalip.whois.data[0].org_country_code);
                const flagUrl = `https://cdnjs.cloudflare.com/ajax/libs/flag-icons/6.6.6/flags/1x1/${countryCode}.svg`;
                addNode(country, country, "country_name", flagUrl);
                edges.push({ from: obs, to: country, label: "Country (CriminalIP)" });
            }

            // AbuseIPDB country (note: AbuseIPDB is NOT an ASN provider, only provides ISP and country)
            if (entry.abuseipdb?.country_code) {
                const countryCode = entry.abuseipdb.country_code.toLowerCase();
                const country = entry.abuseipdb.country_name || country_code_to_country_name(entry.abuseipdb.country_code);
                const flagUrl = `https://cdnjs.cloudflare.com/ajax/libs/flag-icons/6.6.6/flags/1x1/${countryCode}.svg`;

                if (entry.type === "FQDN" || entry.type === "URL") {
                    if (entry.reverse_dns?.reverse_dns && entry.reverse_dns.reverse_dns.length > 0) {
                        // Link country to the first resolved IP
                        const resolvedIp = entry.reverse_dns.reverse_dns[0];
                        addNode(country, country, "country_name", flagUrl);
                        edges.push({ from: resolvedIp, to: country, label: "Country (AbuseIPDB)" });
                    }
                } else {
                    addNode(country, country, "country_name", flagUrl);
                    edges.push({ from: obs, to: country, label: "Country (AbuseIPDB)" });
                }
            }

            // AbuseIPDB ISP (not ASN, just ISP name)
            if (entry.abuseipdb?.isp) {
                const ispNode = entry.abuseipdb.isp;

                if (entry.type === "FQDN" || entry.type === "URL") {
                    if (entry.reverse_dns?.reverse_dns && entry.reverse_dns.reverse_dns.length > 0) {
                        const resolvedIp = entry.reverse_dns.reverse_dns[0];
                        addNode(ispNode, ispNode, "abuseipdb_isp", "https://img.icons8.com/officexs/32/organization.png");
                        edges.push({ from: resolvedIp, to: ispNode, label: "ISP (AbuseIPDB)" });
                    }
                } else {
                    addNode(ispNode, ispNode, "abuseipdb_isp", "https://img.icons8.com/officexs/32/organization.png");
                    edges.push({ from: obs, to: ispNode, label: "ISP (AbuseIPDB)" });
                }
            }

            // AbuseIPDB Tor Exit Node
            if (entry.abuseipdb?.is_tor) {
                const torNode = "Tor Exit Node (AbuseIPDB)";

                if (entry.type === "FQDN" || entry.type === "URL") {
                    if (entry.reverse_dns?.reverse_dns && entry.reverse_dns.reverse_dns.length > 0) {
                        const resolvedIp = entry.reverse_dns.reverse_dns[0];
                        addNode(torNode, torNode, "abuseipdb_tor_exit", "https://img.icons8.com/officexs/32/lock.png");
                        edges.push({ from: resolvedIp, to: torNode, label: "Tor (AbuseIPDB)" });
                    }
                } else {
                    addNode(torNode, torNode, "abuseipdb_tor_exit", "https://img.icons8.com/officexs/32/lock.png");
                    edges.push({ from: obs, to: torNode, label: "Tor (AbuseIPDB)" });
                }
            }

            // AbuseIPDB Whitelisted
            if (entry.abuseipdb?.is_whitelisted) {
                const whitelistedNode = "Whitelisted (AbuseIPDB)";

                if (entry.type === "FQDN" || entry.type === "URL") {
                    if (entry.reverse_dns?.reverse_dns && entry.reverse_dns.reverse_dns.length > 0) {
                        const resolvedIp = entry.reverse_dns.reverse_dns[0];
                        addNode(whitelistedNode, whitelistedNode, "abuseipdb_whitelisted", "https://img.icons8.com/officexs/32/ok.png");
                        edges.push({ from: resolvedIp, to: whitelistedNode, label: "Whitelisted" });
                    }
                } else {
                    addNode(whitelistedNode, whitelistedNode, "abuseipdb_whitelisted", "https://img.icons8.com/officexs/32/ok.png");
                    edges.push({ from: obs, to: whitelistedNode, label: "Whitelisted" });
                }
            }

            // AbuseIPDB Hostnames
            if (entry.abuseipdb?.hostnames && entry.abuseipdb.hostnames.length > 0) {
                entry.abuseipdb.hostnames.forEach((hostname) => {
                    if (entry.type === "FQDN" || entry.type === "URL") {
                        if (entry.reverse_dns?.reverse_dns && entry.reverse_dns.reverse_dns.length > 0) {
                            const resolvedIp = entry.reverse_dns.reverse_dns[0];
                            addNode(hostname, hostname, "abuseipdb_hostname", "https://img.icons8.com/officexs/32/server.png");
                            edges.push({ from: resolvedIp, to: hostname, label: "Hostname (AbuseIPDB)" });
                        }
                    } else {
                        addNode(hostname, hostname, "abuseipdb_hostname", "https://img.icons8.com/officexs/32/server.png");
                        edges.push({ from: obs, to: hostname, label: "Hostname (AbuseIPDB)" });
                    }
                });
            }

            if (entry.reverse_dns?.reverse_dns) {
                entry.reverse_dns.reverse_dns.forEach((reverse) => {
                    addNode(reverse, reverse, "reverse_dns", "https://img.icons8.com/officexs/32/server.png");
                    edges.push({ from: obs, to: reverse, label: "Reverse DNS" });
                });
            }

            if (entry.threatfox?.malware_printable) {
                entry.threatfox.malware_printable.forEach((malware) => {
                    addNode(malware, malware, "malware", "https://img.icons8.com/officexs/32/spam.png");
                    edges.push({ from: obs, to: malware, label: "Malware" });
                });
            }

            if (entry.rosti?.results && entry.rosti.count > 0) {
                entry.rosti.results.forEach((rostiItem) => {
                    const rostiNodeId = rostiItem.value || rostiItem.id || "Rösti IOC";
                    addNode(rostiNodeId, rostiNodeId, "rosti", "https://img.icons8.com/officexs/32/inspection.png");
                    const rostiLabel = rostiItem.type ? `Rösti (${rostiItem.type})` : "Rösti";
                    edges.push({ from: obs, to: rostiNodeId, label: rostiLabel });

                    if (rostiItem.risk?.meaning) {
                        const riskNode = `Rösti risk: ${rostiItem.risk.meaning}`;
                        addNode(riskNode, riskNode, "rosti_risk", "https://img.icons8.com/officexs/32/high-priority.png");
                        edges.push({ from: rostiNodeId, to: riskNode, label: rostiItem.risk.msg || "Risk" });
                    }
                });
            }

            if (entry.bad_asn) {
                const badAsnData = entry.bad_asn;

                // Only create node if ASN is malicious
                if (badAsnData.status === "malicious") {
                    const asnLabel = `Bad ASN: ${badAsnData.asn}`;
                    const asnId = `bad_asn_${badAsnData.asn}`;

                    addNode(
                        asnId,
                        asnLabel,
                        "bad_asn",
                        "https://img.icons8.com/officexs/32/cancel.png"
                    );

                    edges.push({
                        from: obs,
                        to: asnId,
                        label: badAsnData.source || "Bad ASN"
                    });
                }
            }

            if (entry.urlscan?.top_domains) {
                entry.urlscan.top_domains.forEach((domainEntry) => {
                    const domain = domainEntry.domain;
                    addNode(domain, domain, "urlscan_domain", "https://urlscan.io/img/urlscan_256.png");
                    edges.push({ from: obs, to: domain, label: `Related domain (URLscan)` });
                });
            }

            if (entry.crtsh?.top_domains) {
                entry.crtsh.top_domains.forEach((domainEntry) => {
                    const domain = domainEntry.domain;
                    addNode(domain, domain, "crtsh_domain", "https://crt.sh/sectigo_s.png");
                    edges.push({ from: obs, to: domain, label: `Related domain (crt.sh)` });
                });
            }

            if (entry.github?.results) {
                entry.github.results.forEach((githubEntry) => {
                    const githubTitle = githubEntry.title;
                    addNode(
                        githubTitle,
                        githubTitle,
                        "github",
                        "https://img.icons8.com/officexs/32/github.png",
                    );
                    edges.push({ from: obs, to: githubTitle, label: "GitHub" });
                });
            }

            if (entry.google?.results) {
                entry.google.results.forEach((googleEntry) => {
                    const googleTitle = googleEntry.title;
                    if (googleTitle && googleTitle.trim() !== "") {
                        addNode(
                            googleTitle,
                            googleTitle,
                            "google",
                            "https://img.icons8.com/officexs/32/google-logo.png",
                        );
                        edges.push({ from: obs, to: googleTitle, label: "Google" });
                    }
                });
            }

            // Check for Google DNS data
            if (entry.google_dns && entry.google_dns.Answer && Array.isArray(entry.google_dns.Answer)) {
                entry.google_dns.Answer.forEach((dnsRecord) => {
                    const recordType = dnsRecord.type_name ? dnsRecord.type_name.toLowerCase() : "unknown";
                    const group = `google_dns_${recordType}`;
                    addNode(
                        dnsRecord.data,
                        dnsRecord.data,
                        group,
                        "https://img.icons8.com/officexs/32/dns.png"
                    );
                    edges.push({
                        from: obs,
                        to: dnsRecord.data,
                        label: `Google DNS (${dnsRecord.type_name})`
                    });
                });
            }

            if (entry.opencti?.latest_indicator_name && entry.opencti.latest_indicator_name.trim() !== "") {
                const indicatorName = "OpenCTI flagged";
                addNode(
                    indicatorName,
                    indicatorName,
                    "opencti_indicator",
                    "https://img.icons8.com/officexs/32/fire-element.png",
                );
                const revocation_status = entry.opencti.revoked ? "Revoked" : "Active";
                const opencti_score = `Score: ${entry.opencti.x_opencti_score}`;
                edges.push({
                    from: obs,
                    to: indicatorName,
                    label: `OpenCTI indicator (${revocation_status}, ${opencti_score})`,
                });
            }

            if (entry.dfir_iris?.links) {
                const indicatorName = "DFIR-IRIS";
                addNode(
                    indicatorName,
                    indicatorName,
                    "dfir_iris_indicator",
                    "https://img.icons8.com/officexs/32/fire-element.png",
                );
                edges.push({
                    from: obs,
                    to: indicatorName,
                    label: `DFIR-IRIS indicator`,
                });

            }

            if (entry.virustotal && entry.virustotal.total_malicious > 0) {
                const vtNodeLabel = "VT flagged";
                addNode(
                    vtNodeLabel,
                    vtNodeLabel,
                    "virustotal",
                    "https://images.icon-icons.com/2699/PNG/32/virustotal_logo_icon_171247.png",
                );
                let vtEdgeLabel = "";
                if (entry.virustotal.detection_ratio) {
                    vtEdgeLabel += `VT ${entry.virustotal.detection_ratio}`;
                }
                if (entry.virustotal.community_score) {
                    vtEdgeLabel += (vtEdgeLabel ? ", " : "") + `Community: ${entry.virustotal.community_score}`;
                }
                edges.push({ from: obs, to: vtNodeLabel, label: vtEdgeLabel });
            }

            if (entry.type === "Email" && entry.hudsonrock?.stealers) {
                entry.hudsonrock.stealers.forEach((stealer) => {
                    if (stealer.computer_name) {
                        addNode(stealer.computer_name, stealer.computer_name, "compromised_computer");
                        edges.push({
                            from: obs,
                            to: stealer.computer_name,
                            label: "Compromised Computer (Hudson Rock)",
                        });
                    }
                    if (stealer.malware_path) {
                        addNode(stealer.malware_path, stealer.malware_path, "malware_path");
                        edges.push({
                            from: obs,
                            to: stealer.malware_path,
                            label: "Malware Path (Hudson Rock)",
                        });
                    }
                    if (stealer.ip) {
                        addNode(stealer.ip, stealer.ip, "ip");
                        edges.push({ from: obs, to: stealer.ip, label: "IP Address (Hudson Rock)" });
                    }
                    if (stealer.operating_system) {
                        addNode(stealer.operating_system, stealer.operating_system, "operating_system");
                        edges.push({
                            from: obs,
                            to: stealer.operating_system,
                            label: "Operating System (Hudson Rock)",
                        });
                    }
                });
            }

            // Handle Hudson Rock results for FQDN
            if (entry.type === "FQDN" && entry.hudsonrock) {
                const hudsonrock = entry.hudsonrock;

                // Add applications
                if (hudsonrock.applications) {
                    hudsonrock.applications.forEach((app) => {
                        const appKeyword = app.keyword;
                        addNode(appKeyword, appKeyword, "application");
                        edges.push({ from: obs, to: appKeyword, label: "Application (Hudson Rock)" });
                    });
                }

                // Add all_urls (Employee and User URLs)
                if (hudsonrock.data?.all_urls) {
                    hudsonrock.data.all_urls.forEach((urlEntry) => {
                        const url = urlEntry.url;
                        const urlType = urlEntry.type;
                        if (!url.includes("\u2022")) {
                            // Ignore URLs containing "\u2022"
                            addNode(url, url, "url");
                            edges.push({ from: obs, to: url, label: `${urlType} URL (Hudson Rock)` });
                        }
                    });
                }

                // Add stealer families
                if (hudsonrock.stealerFamilies) {
                    Object.keys(hudsonrock.stealerFamilies).forEach((family) => {
                        if (family !== "total" && family.toLowerCase() !== "unknown") {
                            const familyNode = `${family}`;
                            addNode(
                                familyNode,
                                familyNode,
                                "stealer_family",
                                "https://img.icons8.com/officexs/32/spam.png",
                            );
                            edges.push({ from: obs, to: familyNode, label: "Stealer Family (Hudson Rock)" });
                        }
                    });
                }

                // Add third-party domains
                if (hudsonrock.thirdPartyDomains) {
                    hudsonrock.thirdPartyDomains.forEach((domainEntry) => {
                        const domain = domainEntry.domain;
                        if (!domain.includes("\u2022")) {
                            // Ignore domains containing "\u2022"
                            addNode(domain, domain, "third_party_domain");
                            edges.push({ from: obs, to: domain, label: "Third Party Domain (Hudson Rock)" });
                        }
                    });
                }
            }

            if (entry.ioc_one_html?.results) {
                entry.ioc_one_html.results.forEach((result) => {
                    const htmlTitle = result.title;
                    if (htmlTitle && htmlTitle.trim() !== "") {
                        addNode(
                            htmlTitle,
                            htmlTitle,
                            "ioc_one_html",
                            "https://img.icons8.com/officexs/32/document.png",
                        );
                        edges.push({ from: obs, to: htmlTitle, label: "Ioc[.]One" });
                    }
                });
            }

            if (entry.ioc_one_pdf?.results) {
                entry.ioc_one_pdf.results.forEach((result) => {
                    const pdfTitle = result.title;
                    if (pdfTitle && pdfTitle.trim() !== "") {
                        addNode(
                            pdfTitle,
                            pdfTitle,
                            "ioc_one_pdf",
                            "https://img.icons8.com/officexs/32/document.png",
                        );
                        edges.push({ from: obs, to: pdfTitle, label: "Ioc[.]One" });
                    }
                });
            }

            if (entry.mde && typeof entry.mde.organizationPrevalence === "number") {
                if (entry.mde.organizationPrevalence > 0) {
                    const mdeNodeLabel = "MDE observed";
                    addNode(
                        mdeNodeLabel,
                        mdeNodeLabel,
                        "mde",
                        "https://img.icons8.com/officexs/32/user-shield.png"
                    );
                    edges.push({
                        from: obs,
                        to: mdeNodeLabel,
                        label: `Org Prevalence: ${entry.mde.organizationPrevalence}`
                    });
                }
            }

            if (entry.crowdstrike && typeof entry.crowdstrike.device_count === "number") {
                if (entry.crowdstrike.device_count > 0) {
                    const csNodeLabel = "CrowdStrike observed";
                    addNode(
                        csNodeLabel,
                        csNodeLabel,
                        "crowdstrike",
                        "https://img.icons8.com/officexs/32/user-shield.png"
                    );
                    edges.push({
                        from: obs,
                        to: csNodeLabel,
                        label: `Device count: ${entry.crowdstrike.device_count}`
                    });
                }
            }

            // CrowdStrike indicator details
            if (entry.crowdstrike && entry.crowdstrike.indicator_found) {
                // Actors
                if (Array.isArray(entry.crowdstrike.actors)) {
                    entry.crowdstrike.actors.forEach((actor) => {
                        if (actor && actor.trim() !== "") {
                            addNode(
                                actor,
                                actor,
                                "crowdstrike_actor",
                                "https://img.icons8.com/officexs/32/walter-white.png"
                            );
                            edges.push({
                                from: obs,
                                to: actor,
                                label: "CrowdStrike Actor"
                            });
                        }
                    });
                }
                // Threat types
                if (Array.isArray(entry.crowdstrike.threat_types)) {
                    entry.crowdstrike.threat_types.forEach((threatType) => {
                        if (threatType && threatType.trim() !== "") {
                            addNode(
                                threatType,
                                threatType,
                                "crowdstrike_threat_type",
                                "https://img.icons8.com/officexs/32/hacking.png"
                            );
                            edges.push({
                                from: obs,
                                to: threatType,
                                label: "CrowdStrike Threat Type"
                            });
                        }
                    });
                }
                // Kill chain
                if (Array.isArray(entry.crowdstrike.kill_chain)) {
                    entry.crowdstrike.kill_chain.forEach((killChain) => {
                        if (killChain && killChain.trim() !== "") {
                            addNode(
                                killChain,
                                killChain,
                                "crowdstrike_kill_chain",
                                "https://img.icons8.com/officexs/32/hacking.png"
                            );
                            edges.push({
                                from: obs,
                                to: killChain,
                                label: "CrowdStrike Kill Chain"
                            });
                        }
                    });
                }
                // Malware families
                if (Array.isArray(entry.crowdstrike.malware_families)) {
                    entry.crowdstrike.malware_families.forEach((malwareFamily) => {
                        if (malwareFamily && malwareFamily.trim() !== "") {
                            addNode(
                                malwareFamily,
                                malwareFamily,
                                "crowdstrike_malware_family",
                                "https://img.icons8.com/officexs/32/spam.png"
                            );
                            edges.push({
                                from: obs,
                                to: malwareFamily,
                                label: "CrowdStrike Malware Family"
                            });
                        }
                    });
                }
                // Vulnerabilities
                if (Array.isArray(entry.crowdstrike.vulnerabilities)) {
                    entry.crowdstrike.vulnerabilities.forEach((vuln) => {
                        if (vuln && vuln.trim() !== "") {
                            addNode(
                                vuln,
                                vuln,
                                "crowdstrike_vulnerability",
                                "https://img.icons8.com/officexs/32/spam.png"
                            );
                            edges.push({
                                from: obs,
                                to: vuln,
                                label: "CrowdStrike Vulnerability"
                            });
                        }
                    });
                }
            }

            // Alienvault Pulses
            if (entry.alienvault?.pulses) {
                entry.alienvault.pulses.forEach((result) => {
                    const alienTitle = result.title;
                    if (alienTitle && alienTitle.trim() !== "") {
                        addNode(
                            alienTitle,
                            alienTitle,
                            "alienvault_pulse",
                            "https://img.icons8.com/officexs/32/document.png",
                        );
                        edges.push({ from: obs, to: alienTitle, label: "Alienvault Pulse" });
                    }
                });
            }

            // Alienvault Malware families
            if (entry.alienvault?.malware_families) {
                entry.alienvault.malware_families.forEach((alienMalware) => {
                    if (alienMalware && alienMalware.trim() !== "") {
                        addNode(
                            alienMalware,
                            alienMalware,
                            "alienvault_malware",
                            "https://img.icons8.com/officexs/32/spam.png",
                        );
                        edges.push({ from: obs, to: alienMalware, label: "Malware family (alienvault)" });
                    }
                });
            }

            // Alienvault Adversary
            if (entry.alienvault?.adversary) {
                entry.alienvault.adversary.forEach((alienAdvers) => {
                    if (alienAdvers && alienAdvers.trim() !== "") {
                        addNode(
                            alienAdvers,
                            alienAdvers,
                            "alienvault_adversary",
                            "https://img.icons8.com/officexs/32/walter-white.png",
                        );
                        edges.push({ from: obs, to: alienAdvers, label: "Adversary (alienvault)" });
                    }
                });
            }

            // Check for MISP events
            if (entry.misp && entry.misp.events && Array.isArray(entry.misp.events)) {
                entry.misp.events.forEach((mispEvent) => {
                    if (mispEvent.title && mispEvent.url) {
                        addNode(
                            mispEvent.title,
                            mispEvent.title,
                            "misp_event",
                            "https://img.icons8.com/officexs/32/document.png"
                        );
                        edges.push({
                            from: obs,
                            to: mispEvent.title,
                            label: "MISP Event"
                        });
                    }
                });
            }

            // Check for Reversing Labs Spectra Analyze events
            if (entry.rl_analyze && entry.rl_analyze.reports > 0) {
                const rlNodeLabel = "Reversing Labs Spectra Analyze observed";
                addNode(
                    rlNodeLabel,
                    rlNodeLabel,
                    "rl_analyze",
                    "https://img.icons8.com/officexs/32/hacking.png"
                );
                let rlEdgeLabel = "";
                if (entry.rl_analyze.malicious || entry.rl_analyze.suspicious) {
                    rlEdgeLabel += `RL Verdict: ${entry.rl_analyze.malicious}/${entry.rl_analyze.suspicious}/${entry.rl_analyze.reports}`;
                }
                if (entry.rl_analyze.scanners) {
                    rlEdgeLabel += `RL AV: ${entry.rl_analyze.scanners}/${entry.rl_analyze.reports}, ${entry.rl_analyze.classification}`;
                }
                edges.push({ from: obs, to: rlNodeLabel, label: rlEdgeLabel });
            }

            // Check for Chrome / Edge extension data
            if (entry.type == "CHROME_EXTENSION") {
                const extensionName = entry.extension.name;
                addNode(extensionName, extensionName, "extension");
                edges.push({ from: obs, to: extensionName, label: "Extension Name" });
            }

            if (entry.type == "Email") {
                const email = entry.observable;
                const domain = email.split("@")[1]; // Extract the domain name from the email address
                if (domain) {
                    addNode(domain, domain, "domain", "https://img.icons8.com/officexs/32/root-server.png"); // Add the domain as a node if it doesn't already exist
                    edges.push({ from: email, to: domain, label: "Email Domain" }); // Link the email to the domain
                }
            }
        });

        data.forEach((entry) => {
            if ((entry.type === "FQDN" || entry.type === "URL") && entry.rdap_whois) {
                const rdapWhois = entry.rdap_whois;

                if (rdapWhois.registrar) {
                    addNode(
                        rdapWhois.registrar,
                        rdapWhois.registrar,
                        "rdap_whois_registrar",
                        "https://img.icons8.com/officexs/32/organization.png",
                    );
                    edges.push({ from: entry.observable, to: rdapWhois.registrar, label: "Registrar" });
                }

                if (rdapWhois.organization) {
                    addNode(
                        rdapWhois.organization,
                        rdapWhois.organization,
                        "rdap_whois_organization",
                        "https://img.icons8.com/officexs/32/organization.png",
                    );
                    edges.push({ from: entry.observable, to: rdapWhois.organization, label: "Organization" });
                }

                if (rdapWhois.abuse_contact) {
                    addNode(
                        rdapWhois.abuse_contact,
                        rdapWhois.abuse_contact,
                        "rdap_whois_abuse_contact",
                        "https://img.icons8.com/officexs/32/email.png",
                    );
                    edges.push({ from: entry.observable, to: rdapWhois.abuse_contact, label: "Abuse Contact" });
                }

                if (rdapWhois.registrant) {
                    addNode(
                        rdapWhois.registrant,
                        rdapWhois.registrant,
                        "rdap_whois_registrant",
                        "https://img.icons8.com/officexs/32/organization.png",
                    );
                    edges.push({ from: entry.observable, to: rdapWhois.registrant, label: "Registrant" });
                }

                if (rdapWhois.registrant_email) {
                    addNode(
                        rdapWhois.registrant_email,
                        rdapWhois.registrant_email,
                        "rdap_whois_registrant_email",
                        "https://img.icons8.com/officexs/32/email.png",
                    );
                    edges.push({
                        from: entry.observable,
                        to: rdapWhois.registrant_email,
                        label: "Registrant Email",
                    });
                }

                if (rdapWhois.name_servers && Array.isArray(rdapWhois.name_servers)) {
                    rdapWhois.name_servers.forEach((nameServer) => {
                        addNode(
                            nameServer,
                            nameServer,
                            "rdap_whois_name_server",
                            "https://img.icons8.com/officexs/32/dns.png",
                        );
                        edges.push({ from: entry.observable, to: nameServer, label: "Name Server" });
                    });
                }
            }
        });

        const container = document.getElementById("network");
        const networkData = {
            nodes: new vis.DataSet(nodes),
            edges: new vis.DataSet(edges),
        };
        const options = {
            nodes: {
                shape: "dot",
                size: 12,
                font: {
                    size: 12,
                    color: document.body.classList.contains("dark-mode") ? "white" : "black", // Adjust node label color based on mode
                },
            },
            edges: {
                font: {
                    size: 12,
                    align: "horizontal",
                    strokeWidth: 0, // Removes shadow of edge labels
                    color: document.body.classList.contains("dark-mode") ? "white" : "black", // Adjust label color based on mode
                },
            },
            groups: {
                observable: { color: { background: "#ff6f61" } },
                asn: { color: { background: "#87ceeb" } },
                country_name: { color: { background: "#90ee90" } },
                port: { color: { background: "#f5b041" } },
                reverse_dns: { color: { background: "#d4a6ff" } },
                malware: { color: { background: "#ffcccb" } },
                bad_asn: { color: { background: "#ff4444" } },
            },
            physics: {
                stabilization: false,
                barnesHut: { gravitationalConstant: -20000 },
            },
            layout: {
                improvedLayout: true,
            },
        };

        function createContextMenu(node, network, nodesDataSet, edgesDataSet, x, y) {
            const existingMenu = document.getElementById("context-menu");
            if (existingMenu) existingMenu.remove();

            // Create menu
            const menu = document.createElement("div");
            menu.id = "context-menu";
            menu.style.position = "absolute";
            menu.style.background = "#fff";
            menu.style.border = "1px solid #ccc";
            menu.style.boxShadow = "2px 2px 5px rgba(0,0,0,0.2)";
            menu.style.zIndex = "1000";
            menu.style.padding = "5px";
            menu.style.borderRadius = "4px";

            // Option "Show Info"
            const showInfoOption = document.createElement("div");
            showInfoOption.textContent = "Show Info";
            showInfoOption.style.padding = "5px 10px";
            showInfoOption.style.cursor = "pointer";
            showInfoOption.style.color = "#333";
            showInfoOption.addEventListener("mouseover", () => {
                showInfoOption.style.background = "#f0f0f0";
            });
            showInfoOption.addEventListener("mouseout", () => {
                showInfoOption.style.background = "none";
            });
            showInfoOption.addEventListener("click", () => {
                alert(`Node: ${node.label}\nType: ${node.group}`);
                menu.remove();
            });

            // Option "Hide Node"
            const hideNodeOption = document.createElement("div");
            hideNodeOption.textContent = "Hide Node";
            hideNodeOption.style.padding = "5px 10px";
            hideNodeOption.style.cursor = "pointer";
            hideNodeOption.style.color = "#333";
            hideNodeOption.addEventListener("mouseover", () => {
                hideNodeOption.style.background = "#f0f0f0";
            });
            hideNodeOption.addEventListener("mouseout", () => {
                hideNodeOption.style.background = "none";
            });
            hideNodeOption.addEventListener("click", () => {
                // Hide node
                nodesDataSet.remove(node.id);
                // Delete connected Edges
                const connectedEdges = edgesDataSet.get({
                    filter: (edge) => edge.from === node.id || edge.to === node.id,
                });
                edgesDataSet.remove(connectedEdges.map((edge) => edge.id));
                menu.remove();
            });

            // Option "Hide Group"
            const hideGroupOption = document.createElement("div");
            hideGroupOption.textContent = `Hide Group: ${node.group}`;
            hideGroupOption.style.padding = "5px 10px";
            hideGroupOption.style.cursor = "pointer";
            hideGroupOption.style.color = "#333";
            hideGroupOption.addEventListener("mouseover", () => {
                hideGroupOption.style.background = "#f0f0f0";
            });
            hideGroupOption.addEventListener("mouseout", () => {
                hideGroupOption.style.background = "none";
            });
            hideGroupOption.addEventListener("click", () => {
                // Hide all group nodes
                const groupNodes = nodesDataSet.get({
                    filter: (n) => n.group === node.group,
                });
                nodesDataSet.remove(groupNodes.map((n) => n.id));
                // Hide edges
                const connectedEdges = edgesDataSet.get({
                    filter: (edge) => groupNodes.some((n) => edge.from === n.id || edge.to === n.id),
                });
                edgesDataSet.remove(connectedEdges.map((edge) => edge.id));
                menu.remove();
            });

            menu.appendChild(showInfoOption);
            menu.appendChild(hideNodeOption);
            menu.appendChild(hideGroupOption);

            // Position menu
            document.body.appendChild(menu);
            menu.style.left = `${x}px`;
            menu.style.top = `${y}px`;
            return menu;
        }

        const network = new vis.Network(container, networkData, options);
        container.networkInstance = network;

        // Right click
        network.on("oncontext", (params) => {
            const nodeId = network.getNodeAt(params.pointer.DOM);
            if (nodeId) {
                params.event.preventDefault(); // Avoid default context menu for nodes
                const node = nodes.find((n) => n.id === nodeId);
                if (node) {
                    // Get position
                    const containerRect = container.getBoundingClientRect();

                    const adjustedX = params.pointer.DOM.x + containerRect.left + window.scrollX;
                    const adjustedY = params.pointer.DOM.y + containerRect.top + window.scrollY;
                    // Create menu
                    const menu = createContextMenu(
                        node,
                        network,
                        networkData.nodes,
                        networkData.edges,
                        adjustedX + 10,
                        adjustedY + 10,
                    );
                }
            }
        });

        // Close custom context menu
        document.addEventListener("click", () => {
            const existingMenu = document.getElementById("context-menu");
            if (existingMenu) existingMenu.remove();
        });
    }

    // Fetch the analysis results from the server
    fetch(`/{{ API_PREFIX }}/results/{{ analysis_id }}`)
        .then((response) => response.json())
        .then((data) => {
            generateGraph(data);
        })
        .catch((error) => {
            console.error("Error fetching analysis results:", error);
        });
</script>
{% endblock content %}