{% extends "base.html" %}

{% block title %}Cyberbro - Graph Analysis (experimental){% endblock title %}
{% block head %}
    {{ super() }}
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script type="text/javascript" src="https://unpkg.com/vis-network@9.1.2/dist/vis-network.min.js"></script>
    <link href="https://unpkg.com/vis-network@9.1.2/dist/vis-network.min.css" rel="stylesheet" type="text/css" />
    <link rel="stylesheet" href="{{ url_for('static', filename='graph-styles.css') }}">
{% endblcok head %}

{% block content %}
        <h1>{{ self.title() }}</h1>
        <button class="btn" onclick="window.location.href='/results/{{ analysis_id }}'">Go Back</button>
        <button class="btn" onclick="toggleFullScreen()">Full Screen</button>
        <button class="btn" id="layoutButton" onclick="switchLayout()">Switch to Circular</button>
        <button class="btn" id="physicsButton" onclick="togglePhysics()">Stop Physics</button>
        <script>
            let physicsEnabled = true;

            function togglePhysics() {
                const container = document.getElementById("network");
                if (!container) {
                    console.error("Network container not found.");
                    return;
                }

                const network = container.networkInstance;
                if (!network) {
                    console.error("Network instance is not initialized.");
                    return;
                }

                physicsEnabled = !physicsEnabled;
                console.log(`Toggling physics: ${physicsEnabled}`);
                network.setOptions({
                    physics: {
                        enabled: physicsEnabled,
                    },
                });

                const physicsButton = document.getElementById("physicsButton");
                physicsButton.textContent = physicsEnabled ? "Stop Physics" : "Enable Physics";
            }

            let currentLayoutIndex = 0;
            const layouts = [
                { name: "Organic", options: { layout: { randomSeed: undefined } } },
                { name: "Circular", options: { layout: { hierarchical: false } } },
                {
                    name: "Orthogonal",
                    options: { layout: { hierarchical: { direction: "UD", sortMethod: "directed" } } },
                },
                { name: "Tree", options: { layout: { hierarchical: { direction: "LR", sortMethod: "hubsize" } } } },
                {
                    name: "Hierarchical",
                    options: { layout: { hierarchical: { direction: "UD", sortMethod: "directed" } } },
                },
            ];

            function switchLayout() {
                const container = document.getElementById("network");
                const network = container.networkInstance;
                if (!network) {
                    console.error("Network instance is not initialized.");
                    return;
                }

                currentLayoutIndex = (currentLayoutIndex + 1) % layouts.length;
                const selectedLayout = layouts[currentLayoutIndex];
                console.log(`Switching to layout: ${selectedLayout.name}`);

                // Preserve the current physics state
                const currentPhysicsState = physicsEnabled;
                network.setOptions({
                    ...(selectedLayout.options || {}),
                    physics: { enabled: currentPhysicsState },
                });

                const layoutButton = document.getElementById("layoutButton");
                layoutButton.textContent = `Switch to ${layouts[(currentLayoutIndex + 1) % layouts.length].name}`;
            }
        </script>

        <script>
            function toggleFullScreen() {
                const container = document.getElementById("network");
                if (!document.fullscreenElement) {
                    container.requestFullscreen().catch((err) => {
                        console.error(`Error attempting to enable full-screen mode: ${err.message}`);
                    });
                } else {
                    document.exitFullscreen();
                }
            }
        </script>
        <div id="network"></div>
    </div>

    <script>
        // Use the builtin Javascript library to get the country name from the country code
        function country_code_to_country_name(country_code) {
            const regionNames = new Intl.DisplayNames(["en"], { type: "region" });
            return regionNames.of(country_code.toUpperCase());
        }

            function generateGraph(data) {
                const nodes = [];
                const edges = [];
                const addedNodes = new Set();

                function addNode(id, label, group = "default", imageUrl = null) {
                    if (!addedNodes.has(id)) {
                        const newNode = {
                            id,
                            label,
                            group,
                        };

                        if (imageUrl) {
                            newNode.shape = "image";
                            newNode.image = imageUrl;
                        }

                        nodes.push(newNode);
                        addedNodes.add(id);
                    }
                }

                data.forEach((entry) => {
                    const obs = entry.observable;
                    if (!obs) return;

                    addNode(obs, obs, "observable", "https://img.icons8.com/officexs/32/goal.png");

                    const providers = ["ipinfo", "ipquery", "webscout"];
                    providers.forEach((provider) => {
                        if (entry[provider]?.asn) {
                            const asn =
                                provider === "ipquery"
                                    ? `${entry[provider].asn} ${entry[provider].isp}`
                                    : String(entry[provider].asn);
                            if (entry.type === "FQDN" || entry.type === "URL") {
                                if (entry.reverse_dns?.reverse_dns) {
                                    if (
                                        entry[provider].ip &&
                                        entry.reverse_dns.reverse_dns.includes(entry[provider].ip)
                                    ) {
                                        addNode(asn, asn, "asn", "https://img.icons8.com/officexs/32/organization.png");
                                        edges.push({ from: entry[provider].ip, to: asn, label: `ASN (${provider})` });
                                    }
                                }
                            } else {
                                addNode(asn, asn, "asn", "https://img.icons8.com/officexs/32/organization.png");
                                edges.push({ from: obs, to: asn, label: `ASN (${provider})` });
                            }
                        }

                        if (entry[provider]?.country_code) {
                            // Check to see if the provider already has a country name
                            const country = entry[provider]?.country_name
                                ? entry[provider].country_name
                                : country_code_to_country_name(entry[provider].country_code);
                            const countryCode = entry[provider].country_code.toLowerCase();
                            const flagUrl = `https://raw.githubusercontent.com/lipis/flag-icons/refs/heads/main/flags/1x1/${countryCode}.svg`;

                            addNode(country, country, "country_name", flagUrl);

                            const fromNode =
                                (entry.type === "FQDN" || entry.type === "URL") &&
                                entry.reverse_dns?.reverse_dns?.includes(entry[provider].ip)
                                    ? entry[provider].ip
                                    : obs;

                            edges.push({ from: fromNode, to: country, label: `Country (${provider})` });
                        }

                        // Check if the provider has an IP address
                        if (entry[provider]?.ip) {
                            // Check for IP address with Spur.us data
                            if (entry.spur?.tunnels && entry.spur.tunnels !== "Not anonymous") {
                                const tunnels = entry.spur.tunnels;
                                if (entry.type === "FQDN" || entry.type === "URL") {
                                    if (entry.reverse_dns?.reverse_dns) {
                                        if (
                                            entry[provider].ip &&
                                            entry.reverse_dns.reverse_dns.includes(entry[provider].ip)
                                        ) {
                                            addNode(
                                                tunnels,
                                                tunnels,
                                                "tunnels",
                                                "https://img.icons8.com/officexs/32/lock.png",
                                            );
                                            edges.push({
                                                from: entry[provider].ip,
                                                to: tunnels,
                                                label: "Tunnel (Spur.us)",
                                            });
                                        }
                                    }
                                } else {
                                    addNode(tunnels, tunnels, "tunnels", "https://img.icons8.com/officexs/32/lock.png");
                                    edges.push({ from: obs, to: tunnels, label: "Tunnel (Spur.us)" });
                                }
                            }

                            // Check for Abusix data
                            if (entry.abusix?.abuse) {
                                const abuseAddress = entry.abusix.abuse;
                                if (entry.type === "FQDN" || entry.type === "URL") {
                                    if (entry.reverse_dns?.reverse_dns) {
                                        if (
                                            entry[provider].ip &&
                                            entry.reverse_dns.reverse_dns.includes(entry[provider].ip)
                                        ) {
                                            addNode(
                                                abuseAddress,
                                                abuseAddress,
                                                "abuse",
                                                "https://img.icons8.com/officexs/32/email.png",
                                            );
                                            edges.push({
                                                from: entry[provider].ip,
                                                to: abuseAddress,
                                                label: "Abuse (Abusix)",
                                            });
                                        }
                                    }
                                } else {
                                    addNode(
                                        abuseAddress,
                                        abuseAddress,
                                        "abuse",
                                        "https://img.icons8.com/officexs/32/email.png",
                                    );
                                    edges.push({ from: obs, to: abuseAddress, label: "Abuse (Abusix)" });
                                }
                            }

                            // Check for Shodan data
                            if (entry.shodan?.ports) {
                                entry.shodan.ports.forEach((port) => {
                                    const portNode = `Port ${port}`;
                                    if (entry.type === "FQDN" || entry.type === "URL") {
                                        if (entry.reverse_dns?.reverse_dns) {
                                            if (
                                                entry[provider].ip &&
                                                entry.reverse_dns.reverse_dns.includes(entry[provider].ip)
                                            ) {
                                                addNode(portNode, portNode, "port");
                                                edges.push({
                                                    from: entry[provider].ip,
                                                    to: portNode,
                                                    label: "Port",
                                                });
                                            }
                                        }
                                    } else {
                                        addNode(portNode, portNode, "port");
                                        edges.push({ from: obs, to: portNode, label: "Port" });
                                    }
                                });
                            }

                            if (entry.abuseipdb) {
                                const abuseipdbData = entry.abuseipdb;

                                // Skip adding a node if both reports and risk_score are 0
                                if (abuseipdbData.reports === 0 && abuseipdbData.risk_score === 0) {
                                    return;
                                }

                                const abuseipdbNode = "AbuseIPDB flagged";
                                let edgeLabel = "";

                                if (abuseipdbData.reports) {
                                    edgeLabel += `Reports: ${abuseipdbData.reports}`;
                                }
                                if (abuseipdbData.risk_score) {
                                    edgeLabel += (edgeLabel ? ", " : "") + `Risk: ${abuseipdbData.risk_score} %`;
                                }

                                if (entry.type === "FQDN" || entry.type === "URL") {
                                    if (entry.reverse_dns?.reverse_dns) {
                                        if (
                                            entry[provider]?.ip &&
                                            entry.reverse_dns.reverse_dns.includes(entry[provider]?.ip)
                                        ) {
                                            addNode(
                                                abuseipdbNode,
                                                abuseipdbNode,
                                                "abuseipdb_flagged",
                                                "https://www.abuseipdb.com/img/abuseipdb-logo.svg",
                                            );
                                            edges.push({
                                                from: entry[provider]?.ip,
                                                to: abuseipdbNode,
                                                label: edgeLabel,
                                            });
                                        }
                                    }
                                } else {
                                    addNode(
                                        abuseipdbNode,
                                        abuseipdbNode,
                                        "abuseipdb_flagged",
                                        "https://www.abuseipdb.com/img/abuseipdb-logo.svg",
                                    );
                                    edges.push({ from: obs, to: abuseipdbNode, label: edgeLabel });
                                }
                            }
                        }

                        // end of provider loop
                    });

                    if (entry.criminalip?.abuse_record_count > 0) {
                        const criminalipNode = "Criminal IP flagged";
                        addNode(
                            criminalipNode,
                            criminalipNode,
                            "criminalip_flagged",
                            "https://img.icons8.com/?size=32&id=hm3q4mXLU6tz&format=png&color=000000",
                        );
                        edges.push({
                            from: obs,
                            to: criminalipNode,
                            label: `CriminalIP (${entry.criminalip.abuse_record_count})`,
                        });
                    }

                    if (entry.criminalip?.whois?.data[0]?.as_no) {
                        const asn = `${entry.criminalip.whois.data[0].as_no} ${entry.criminalip.whois.data[0].as_name}`;
                        addNode(asn, asn, "asn", "https://img.icons8.com/officexs/32/organization.png");
                        edges.push({ from: obs, to: asn, label: `ASN (Criminal IP)` });
                    }

                    if (entry.criminalip?.whois?.data[0]?.org_country_code) {
                        const countryCode = entry.criminalip.whois.data[0].org_country_code.toLowerCase();
                        const country = country_code_to_country_name(entry.criminalip.whois.data[0].org_country_code);
                        const flagUrl = `https://raw.githubusercontent.com/lipis/flag-icons/refs/heads/main/flags/1x1/${countryCode}.svg`;
                        addNode(country, country, "country_name", flagUrl);
                        edges.push({ from: obs, to: country, label: "Country (CriminalIP)" });
                    }

                    if (entry.reverse_dns?.reverse_dns) {
                        entry.reverse_dns.reverse_dns.forEach((reverse) => {
                            addNode(reverse, reverse, "reverse_dns", "https://img.icons8.com/officexs/32/server.png");
                            edges.push({ from: obs, to: reverse, label: "Reverse DNS" });
                        });
                    }

                    if (entry.threatfox?.malware_printable) {
                        entry.threatfox.malware_printable.forEach((malware) => {
                            addNode(malware, malware, "malware", "https://img.icons8.com/officexs/32/spam.png");
                            edges.push({ from: obs, to: malware, label: "Malware" });
                        });
                    }

                    if (entry.urlscan?.top_domains) {
                        entry.urlscan.top_domains.forEach((domainEntry) => {
                            const domain = domainEntry.domain;
                            addNode(domain, domain, "domain", "https://urlscan.io/img/urlscan_256.png");
                            edges.push({ from: obs, to: domain, label: `Related domain (URLscan)` });
                        });
                    }

                    if (entry.github?.results) {
                        entry.github.results.forEach((githubEntry) => {
                            const githubTitle = githubEntry.title;
                            addNode(
                                githubTitle,
                                githubTitle,
                                "github",
                                "https://img.icons8.com/officexs/32/github.png",
                            );
                            edges.push({ from: obs, to: githubTitle, label: "GitHub" });
                        });
                    }

                    if (entry.google?.results) {
                        entry.google.results.forEach((googleEntry) => {
                            const googleTitle = googleEntry.title;
                            if (googleTitle && googleTitle.trim() !== "") {
                                addNode(
                                    googleTitle,
                                    googleTitle,
                                    "google",
                                    "https://img.icons8.com/officexs/32/google-logo.png",
                                );
                                edges.push({ from: obs, to: googleTitle, label: "Google" });
                            }
                        });
                    }

                    if (entry.opencti?.latest_indicator_name && entry.opencti.latest_indicator_name.trim() !== "") {
                        const indicatorName = "OpenCTI flagged";
                        addNode(
                            indicatorName,
                            indicatorName,
                            "opencti_indicator",
                            "https://img.icons8.com/officexs/32/fire-element.png",
                        );
                        const revocation_status = entry.opencti.revoked ? "Revoked" : "Active";
                        const opencti_score = `Score: ${entry.opencti.x_opencti_score}`;
                        edges.push({
                            from: obs,
                            to: indicatorName,
                            label: `OpenCTI indicator (${revocation_status}, ${opencti_score})`,
                        });
                    }

                    if (entry.virustotal && entry.virustotal.total_malicious > 0) {
                        const vtNodeLabel = "VT flagged";
                        addNode(
                            vtNodeLabel,
                            vtNodeLabel,
                            "virustotal",
                            "https://images.icon-icons.com/2699/PNG/32/virustotal_logo_icon_171247.png",
                        );
                        let vtEdgeLabel = "";
                        if (entry.virustotal.detection_ratio) {
                            vtEdgeLabel += `VT ${entry.virustotal.detection_ratio}`;
                        }
                        if (entry.virustotal.community_score) {
                            vtEdgeLabel += (vtEdgeLabel ? ", " : "") + `Community: ${entry.virustotal.community_score}`;
                        }
                        edges.push({ from: obs, to: vtNodeLabel, label: vtEdgeLabel });
                    }

                    if (entry.type === "Email" && entry.hudsonrock?.stealers) {
                        entry.hudsonrock.stealers.forEach((stealer) => {
                            if (stealer.computer_name) {
                                addNode(stealer.computer_name, stealer.computer_name, "compromised_computer");
                                edges.push({
                                    from: obs,
                                    to: stealer.computer_name,
                                    label: "Compromised Computer (Hudson Rock)",
                                });
                            }
                            if (stealer.malware_path) {
                                addNode(stealer.malware_path, stealer.malware_path, "malware_path");
                                edges.push({
                                    from: obs,
                                    to: stealer.malware_path,
                                    label: "Malware Path (Hudson Rock)",
                                });
                            }
                            if (stealer.ip) {
                                addNode(stealer.ip, stealer.ip, "ip");
                                edges.push({ from: obs, to: stealer.ip, label: "IP Address (Hudson Rock)" });
                            }
                            if (stealer.operating_system) {
                                addNode(stealer.operating_system, stealer.operating_system, "operating_system");
                                edges.push({
                                    from: obs,
                                    to: stealer.operating_system,
                                    label: "Operating System (Hudson Rock)",
                                });
                            }
                        });
                    }

                    // Handle Hudson Rock results for FQDN
                    if (entry.type === "FQDN" && entry.hudsonrock) {
                        const hudsonrock = entry.hudsonrock;

                        // Add applications
                        if (hudsonrock.applications) {
                            hudsonrock.applications.forEach((app) => {
                                const appKeyword = app.keyword;
                                addNode(appKeyword, appKeyword, "application");
                                edges.push({ from: obs, to: appKeyword, label: "Application (Hudson Rock)" });
                            });
                        }

                        // Add all_urls (Employee and User URLs)
                        if (hudsonrock.data?.all_urls) {
                            hudsonrock.data.all_urls.forEach((urlEntry) => {
                                const url = urlEntry.url;
                                const urlType = urlEntry.type;
                                if (!url.includes("\u2022")) {
                                    // Ignore URLs containing "\u2022"
                                    addNode(url, url, "url");
                                    edges.push({ from: obs, to: url, label: `${urlType} URL (Hudson Rock)` });
                                }
                            });
                        }

                        // Add stealer families
                        if (hudsonrock.stealerFamilies) {
                            Object.keys(hudsonrock.stealerFamilies).forEach((family) => {
                                if (family !== "total" && family.toLowerCase() !== "unknown") {
                                    const familyNode = `${family}`;
                                    addNode(
                                        familyNode,
                                        familyNode,
                                        "stealer_family",
                                        "https://img.icons8.com/officexs/32/spam.png",
                                    );
                                    edges.push({ from: obs, to: familyNode, label: "Stealer Family (Hudson Rock)" });
                                }
                            });
                        }

                        // Add third-party domains
                        if (hudsonrock.thirdPartyDomains) {
                            hudsonrock.thirdPartyDomains.forEach((domainEntry) => {
                                const domain = domainEntry.domain;
                                if (!domain.includes("\u2022")) {
                                    // Ignore domains containing "\u2022"
                                    addNode(domain, domain, "third_party_domain");
                                    edges.push({ from: obs, to: domain, label: "Third Party Domain (Hudson Rock)" });
                                }
                            });
                        }
                    }

                    if (entry.ioc_one_html?.results) {
                        entry.ioc_one_html.results.forEach((result) => {
                            const htmlTitle = result.title;
                            if (htmlTitle && htmlTitle.trim() !== "") {
                                addNode(
                                    htmlTitle,
                                    htmlTitle,
                                    "ioc_one_html",
                                    "https://img.icons8.com/officexs/32/document.png",
                                );
                                edges.push({ from: obs, to: htmlTitle, label: "Ioc[.]One" });
                            }
                        });
                    }

                    if (entry.ioc_one_pdf?.results) {
                        entry.ioc_one_pdf.results.forEach((result) => {
                            const pdfTitle = result.title;
                            if (pdfTitle && pdfTitle.trim() !== "") {
                                addNode(
                                    pdfTitle,
                                    pdfTitle,
                                    "ioc_one_pdf",
                                    "https://img.icons8.com/officexs/32/document.png",
                                );
                                edges.push({ from: obs, to: pdfTitle, label: "Ioc[.]One" });
                            }
                        });
                    }

                    // Alienvault Pulses
                    if (entry.alienvault?.pulses) {
                        entry.alienvault.pulses.forEach((result) => {
                            const alienTitle = result.title;
                            if (alienTitle && alienTitle.trim() !== "") {
                                addNode(
                                    alienTitle,
                                    alienTitle,
                                    "alienvault_pulse",
                                    "https://img.icons8.com/officexs/32/document.png",
                                );
                                edges.push({ from: obs, to: alienTitle, label: "Alienvault Pulse" });
                            }
                        });
                    }

                    // Alienvault Malware families
                    if (entry.alienvault?.malware_families) {
                        entry.alienvault.malware_families.forEach((alienMalware) => {
                            if (alienMalware && alienMalware.trim() !== "") {
                                addNode(
                                    alienMalware,
                                    alienMalware,
                                    "alienvault_malware",
                                    "https://img.icons8.com/officexs/32/spam.png",
                                );
                                edges.push({ from: obs, to: alienMalware, label: "Malware family (alienvault)" });
                            }
                        });
                    }

                    // Alienvault Adversary
                    if (entry.alienvault?.adversary) {
                        entry.alienvault.adversary.forEach((alienAdvers) => {
                            if (alienAdvers && alienAdvers.trim() !== "") {
                                addNode(
                                    alienAdvers,
                                    alienAdvers,
                                    "alienvault_pulse",
                                    "https://img.icons8.com/officexs/32/walter-white.png",
                                );
                                edges.push({ from: obs, to: alienAdvers, label: "Adversary (alienvault)" });
                            }
                        });
                    }

                    // Check for Chrome / Edge extension data
                    if (entry.type == "CHROME_EXTENSION") {
                        const extensionName = entry.extension.name;
                        addNode(extensionName, extensionName, "extension");
                        edges.push({ from: obs, to: extensionName, label: "Extension Name" });
                    }

                    if (entry.type == "Email") {
                        const email = entry.observable;
                        const domain = email.split("@")[1]; // Extract the domain name from the email address
                        if (domain) {
                            addNode(domain, domain, "domain", "https://img.icons8.com/officexs/32/root-server.png"); // Add the domain as a node if it doesn't already exist
                            edges.push({ from: email, to: domain, label: "Email Domain" }); // Link the email to the domain
                        }
                    }
                });

                data.forEach((entry) => {
                    if ((entry.type === "FQDN" || entry.type === "URL") && entry.rdap) {
                        const rdap = entry.rdap;

                        if (rdap.registrar) {
                            addNode(
                                rdap.registrar,
                                rdap.registrar,
                                "rdap_registrar",
                                "https://img.icons8.com/officexs/32/organization.png",
                            );
                            edges.push({ from: entry.observable, to: rdap.registrar, label: "Registrar" });
                        }

                        if (rdap.organization) {
                            addNode(
                                rdap.organization,
                                rdap.organization,
                                "rdap_organization",
                                "https://img.icons8.com/officexs/32/organization.png",
                            );
                            edges.push({ from: entry.observable, to: rdap.organization, label: "Organization" });
                        }

                        if (rdap.abuse_contact) {
                            addNode(
                                rdap.abuse_contact,
                                rdap.abuse_contact,
                                "rdap_abuse_contact",
                                "https://img.icons8.com/officexs/32/email.png",
                            );
                            edges.push({ from: entry.observable, to: rdap.abuse_contact, label: "Abuse Contact" });
                        }

                        if (rdap.registrant) {
                            addNode(
                                rdap.registrant,
                                rdap.registrant,
                                "rdap_registrant",
                                "https://img.icons8.com/officexs/32/organization.png",
                            );
                            edges.push({ from: entry.observable, to: rdap.registrant, label: "Registrant" });
                        }

                        if (rdap.registrant_email) {
                            addNode(
                                rdap.registrant_email,
                                rdap.registrant_email,
                                "rdap_registrant_email",
                                "https://img.icons8.com/officexs/32/email.png",
                            );
                            edges.push({
                                from: entry.observable,
                                to: rdap.registrant_email,
                                label: "Registrant Email",
                            });
                        }

                        if (rdap.name_servers && Array.isArray(rdap.name_servers)) {
                            rdap.name_servers.forEach((nameServer) => {
                                addNode(
                                    nameServer,
                                    nameServer,
                                    "rdap_name_server",
                                    "https://img.icons8.com/officexs/32/dns.png",
                                );
                                edges.push({ from: entry.observable, to: nameServer, label: "Name Server" });
                            });
                        }
                    }
                });

                const container = document.getElementById("network");
                const networkData = {
                    nodes: new vis.DataSet(nodes),
                    edges: new vis.DataSet(edges),
                };
                const options = {
                    nodes: {
                        shape: "dot",
                        size: 12,
                        font: {
                            size: 12,
                            color: document.body.classList.contains("dark-mode") ? "white" : "black", // Adjust node label color based on mode
                        },
                    },
                    edges: {
                        font: {
                            size: 12,
                            align: "horizontal",
                            strokeWidth: 0, // Removes shadow of edge labels
                            color: document.body.classList.contains("dark-mode") ? "white" : "black", // Adjust label color based on mode
                        },
                    },
                    groups: {
                        observable: { color: { background: "#ff6f61" } },
                        asn: { color: { background: "#87ceeb" } },
                        country_name: { color: { background: "#90ee90" } },
                        port: { color: { background: "#f5b041" } },
                        reverse_dns: { color: { background: "#d4a6ff" } },
                        malware: { color: { background: "#ffcccb" } },
                    },
                    physics: {
                        stabilization: false,
                        barnesHut: { gravitationalConstant: -20000 },
                    },
                    layout: {
                        improvedLayout: true,
                    },
                };

                function createContextMenu(node, network, nodesDataSet, edgesDataSet, x, y) {
                    const existingMenu = document.getElementById("context-menu");
                    if (existingMenu) existingMenu.remove();

                    // Create menu
                    const menu = document.createElement("div");
                    menu.id = "context-menu";
                    menu.style.position = "absolute";
                    menu.style.background = "#fff";
                    menu.style.border = "1px solid #ccc";
                    menu.style.boxShadow = "2px 2px 5px rgba(0,0,0,0.2)";
                    menu.style.zIndex = "1000";
                    menu.style.padding = "5px";
                    menu.style.borderRadius = "4px";

                    // Option "Show Info"
                    const showInfoOption = document.createElement("div");
                    showInfoOption.textContent = "Show Info";
                    showInfoOption.style.padding = "5px 10px";
                    showInfoOption.style.cursor = "pointer";
                    showInfoOption.style.color = "#333";
                    showInfoOption.addEventListener("mouseover", () => {
                        showInfoOption.style.background = "#f0f0f0";
                    });
                    showInfoOption.addEventListener("mouseout", () => {
                        showInfoOption.style.background = "none";
                    });
                    showInfoOption.addEventListener("click", () => {
                        alert(`Node: ${node.label}\nType: ${node.group}`);
                        menu.remove();
                    });

                    // Option "Hide Node"
                    const hideNodeOption = document.createElement("div");
                    hideNodeOption.textContent = "Hide Node";
                    hideNodeOption.style.padding = "5px 10px";
                    hideNodeOption.style.cursor = "pointer";
                    hideNodeOption.style.color = "#333";
                    hideNodeOption.addEventListener("mouseover", () => {
                        hideNodeOption.style.background = "#f0f0f0";
                    });
                    hideNodeOption.addEventListener("mouseout", () => {
                        hideNodeOption.style.background = "none";
                    });
                    hideNodeOption.addEventListener("click", () => {
                        // Hide node
                        nodesDataSet.remove(node.id);
                        // Delete connected Edges
                        const connectedEdges = edgesDataSet.get({
                            filter: (edge) => edge.from === node.id || edge.to === node.id,
                        });
                        edgesDataSet.remove(connectedEdges.map((edge) => edge.id));
                        menu.remove();
                    });

                    // Option "Hide Group"
                    const hideGroupOption = document.createElement("div");
                    hideGroupOption.textContent = `Hide Group: ${node.group}`;
                    hideGroupOption.style.padding = "5px 10px";
                    hideGroupOption.style.cursor = "pointer";
                    hideGroupOption.style.color = "#333";
                    hideGroupOption.addEventListener("mouseover", () => {
                        hideGroupOption.style.background = "#f0f0f0";
                    });
                    hideGroupOption.addEventListener("mouseout", () => {
                        hideGroupOption.style.background = "none";
                    });
                    hideGroupOption.addEventListener("click", () => {
                        // Hide all group nodes
                        const groupNodes = nodesDataSet.get({
                            filter: (n) => n.group === node.group,
                        });
                        nodesDataSet.remove(groupNodes.map((n) => n.id));
                        // Hide edges
                        const connectedEdges = edgesDataSet.get({
                            filter: (edge) => groupNodes.some((n) => edge.from === n.id || edge.to === n.id),
                        });
                        edgesDataSet.remove(connectedEdges.map((edge) => edge.id));
                        menu.remove();
                    });

                    menu.appendChild(showInfoOption);
                    menu.appendChild(hideNodeOption);
                    menu.appendChild(hideGroupOption);

                    // Position menu
                    document.body.appendChild(menu);
                    menu.style.left = `${x}px`;
                    menu.style.top = `${y}px`;
                    return menu;
                }

                const network = new vis.Network(container, networkData, options);
                container.networkInstance = network;

                // Right click
                network.on("oncontext", (params) => {
                    const nodeId = network.getNodeAt(params.pointer.DOM);
                    if (nodeId) {
                        params.event.preventDefault(); // Avoid default context menu for nodes
                        const node = nodes.find((n) => n.id === nodeId);
                        if (node) {
                            // Get position
                            const containerRect = container.getBoundingClientRect();

                            const adjustedX = params.pointer.DOM.x + containerRect.left + window.scrollX;
                            const adjustedY = params.pointer.DOM.y + containerRect.top + window.scrollY;
                            // Create menu
                            const menu = createContextMenu(
                                node,
                                network,
                                networkData.nodes,
                                networkData.edges,
                                adjustedX + 10,
                                adjustedY + 10,
                            );
                        }
                    }
                });

                // Close custom context menu
                document.addEventListener("click", () => {
                    const existingMenu = document.getElementById("context-menu");
                    if (existingMenu) existingMenu.remove();
                });
            }

            // Fetch the analysis results from the server
            fetch(`/{{ API_PREFIX }}/results/{{ analysis_id }}`)
                .then((response) => response.json())
                .then((data) => {
                    generateGraph(data);
                })
                .catch((error) => {
                    console.error("Error fetching analysis results:", error);
                });
        </script>
{% endblock content %}
